/*! For license information please see 59004.5007517e.js.LICENSE.txt */
(self.webpackChunkturf_www=self.webpackChunkturf_www||[]).push([[59004],{59004:function(t){t.exports=function(){"use strict";function t(t,e){var n,r,i,o,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:l(0),throw:l(1),return:l(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function l(t){return function(e){return h([t,e])}}function h(o){if(n)throw new TypeError("Generator is already executing.");for(;s;)try{if(n=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return s.label++,{value:o[1],done:!1};case 5:s.label++,r=o[1],o=[0];continue;case 7:o=s.ops.pop(),s.trys.pop();continue;default:if(!((i=(i=s.trys).length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){s=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){s.label=o[1];break}if(6===o[0]&&s.label<i[1]){s.label=i[1],i=o;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(o);break}i[2]&&s.ops.pop(),s.trys.pop();continue}o=e.call(t,s)}catch(l){o=[6,l],r=0}finally{n=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}}var e=function(){function t(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return t}();function n(t,e){return t>e?1:t<e?-1:0}function r(t,n,r){for(var i=new e(null,null),o=i,s=i;;){var l=r(t,n.key);if(l<0){if(null===n.left)break;if(r(t,n.left.key)<0){var h=n.left;if(n.left=h.right,h.right=n,null===(n=h).left)break}s.left=n,s=n,n=n.left}else{if(!(l>0))break;if(null===n.right)break;if(r(t,n.right.key)>0&&(h=n.right,n.right=h.left,h.left=n,null===(n=h).right))break;o.right=n,o=n,n=n.right}}return o.right=n.left,s.left=n.right,n.left=i.right,n.right=i.left,n}function i(t,n,i,o){var s=new e(t,n);if(null===i)return s.left=s.right=null,s;var l=o(t,(i=r(t,i,o)).key);return l<0?(s.left=i.left,s.right=i,i.left=null):l>=0&&(s.right=i.right,s.left=i,i.right=null),s}function o(t,e,n){var i=null,o=null;if(e){var s=n((e=r(t,e,n)).key,t);0===s?(i=e.left,o=e.right):s<0?(o=e.right,e.right=null,i=e):(i=e.left,e.left=null,o=e)}return{left:i,right:o}}function s(t,e,n){return null===e?t:(null===t||((e=r(t.key,e,n)).left=t),e)}function l(t,e,n,r,i){if(t){r(e+(n?"\u2514\u2500\u2500 ":"\u251c\u2500\u2500 ")+i(t)+"\n");var o=e+(n?"    ":"\u2502   ");t.left&&l(t.left,o,!1,r,i),t.right&&l(t.right,o,!0,r,i)}}var h=function(){function h(t){void 0===t&&(t=n),this._root=null,this._size=0,this._comparator=t}return h.prototype.insert=function(t,e){return this._size++,this._root=i(t,e,this._root,this._comparator)},h.prototype.add=function(t,n){var i=new e(t,n);null===this._root&&(i.left=i.right=null,this._size++,this._root=i);var o=this._comparator,s=r(t,this._root,o),l=o(t,s.key);return 0===l?this._root=s:(l<0?(i.left=s.left,i.right=s,s.left=null):l>0&&(i.right=s.right,i.left=s,s.right=null),this._size++,this._root=i),this._root},h.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},h.prototype._remove=function(t,e,n){var i;return null===e?null:0===n(t,(e=r(t,e,n)).key)?(null===e.left?i=e.right:(i=r(t,e.left,n)).right=e.right,this._size--,i):e},h.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=r(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},h.prototype.findStatic=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(0===r)return e;e=r<0?e.left:e.right}return null},h.prototype.find=function(t){return this._root&&(this._root=r(t,this._root,this._comparator),0!==this._comparator(t,this._root.key))?null:this._root},h.prototype.contains=function(t){for(var e=this._root,n=this._comparator;e;){var r=n(t,e.key);if(0===r)return!0;e=r<0?e.left:e.right}return!1},h.prototype.forEach=function(t,e){for(var n=this._root,r=[],i=!1;!i;)null!==n?(r.push(n),n=n.left):0!==r.length?(n=r.pop(),t.call(e,n),n=n.right):i=!0;return this},h.prototype.range=function(t,e,n,r){for(var i=[],o=this._comparator,s=this._root;0!==i.length||s;)if(s)i.push(s),s=s.left;else{if(o((s=i.pop()).key,e)>0)break;if(o(s.key,t)>=0&&n.call(r,s))return this;s=s.right}return this},h.prototype.keys=function(){var t=[];return this.forEach((function(e){var n=e.key;return t.push(n)})),t},h.prototype.values=function(){var t=[];return this.forEach((function(e){var n=e.data;return t.push(n)})),t},h.prototype.min=function(){return this._root?this.minNode(this._root).key:null},h.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},h.prototype.minNode=function(t){if(void 0===t&&(t=this._root),t)for(;t.left;)t=t.left;return t},h.prototype.maxNode=function(t){if(void 0===t&&(t=this._root),t)for(;t.right;)t=t.right;return t},h.prototype.at=function(t){for(var e=this._root,n=!1,r=0,i=[];!n;)if(e)i.push(e),e=e.left;else if(i.length>0){if(e=i.pop(),r===t)return e;r++,e=e.right}else n=!0;return null},h.prototype.next=function(t){var e=this._root,n=null;if(t.right){for(n=t.right;n.left;)n=n.left;return n}for(var r=this._comparator;e;){var i=r(t.key,e.key);if(0===i)break;i<0?(n=e,e=e.left):e=e.right}return n},h.prototype.prev=function(t){var e=this._root,n=null;if(null!==t.left){for(n=t.left;n.right;)n=n.right;return n}for(var r=this._comparator;e;){var i=r(t.key,e.key);if(0===i)break;i<0?e=e.left:(n=e,e=e.right)}return n},h.prototype.clear=function(){return this._root=null,this._size=0,this},h.prototype.toList=function(){return c(this._root)},h.prototype.load=function(t,e,n){void 0===e&&(e=[]),void 0===n&&(n=!1);var r=t.length,i=this._comparator;if(n&&a(t,e,0,r-1,i),null===this._root)this._root=u(t,e,0,r),this._size=r;else{var o=g(this.toList(),f(t,e),i);r=this._size+r,this._root=p({head:o},0,r)}return this},h.prototype.isEmpty=function(){return null===this._root},Object.defineProperty(h.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(h.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),h.prototype.toString=function(t){void 0===t&&(t=function(t){return String(t.key)});var e=[];return l(this._root,"",!0,(function(t){return e.push(t)}),t),e.join("")},h.prototype.update=function(t,e,n){var r=this._comparator,l=o(t,this._root,r),h=l.left,u=l.right;r(t,e)<0?u=i(e,n,u,r):h=i(e,n,h,r),this._root=s(h,u,r)},h.prototype.split=function(t){return o(t,this._root,this._comparator)},h.prototype[Symbol.iterator]=function(){var e,n,r;return t(this,(function(t){switch(t.label){case 0:e=this._root,n=[],r=!1,t.label=1;case 1:return r?[3,6]:null===e?[3,2]:(n.push(e),e=e.left,[3,5]);case 2:return 0===n.length?[3,4]:[4,e=n.pop()];case 3:return t.sent(),e=e.right,[3,5];case 4:r=!0,t.label=5;case 5:return[3,1];case 6:return[2]}}))},h}();function u(t,n,r,i){var o=i-r;if(o>0){var s=r+Math.floor(o/2),l=t[s],h=n[s],f=new e(l,h);return f.left=u(t,n,r,s),f.right=u(t,n,s+1,i),f}return null}function f(t,n){for(var r=new e(null,null),i=r,o=0;o<t.length;o++)i=i.next=new e(t[o],n[o]);return i.next=null,r.next}function c(t){for(var n=t,r=[],i=!1,o=new e(null,null),s=o;!i;)n?(r.push(n),n=n.left):r.length>0?n=(n=s=s.next=r.pop()).right:i=!0;return s.next=null,o.next}function p(t,e,n){var r=n-e;if(r>0){var i=e+Math.floor(r/2),o=p(t,e,i),s=t.head;return s.left=o,t.head=t.head.next,s.right=p(t,i+1,n),s}return null}function g(t,n,r){for(var i=new e(null,null),o=i,s=t,l=n;null!==s&&null!==l;)r(s.key,l.key)<0?(o.next=s,s=s.next):(o.next=l,l=l.next),o=o.next;return null!==s?o.next=s:null!==l&&(o.next=l),i.next}function a(t,e,n,r,i){if(!(n>=r)){for(var o=t[n+r>>1],s=n-1,l=r+1;;){do{s++}while(i(t[s],o)<0);do{l--}while(i(t[l],o)>0);if(s>=l)break;var h=t[s];t[s]=t[l],t[l]=h,h=e[s],e[s]=e[l],e[l]=h}a(t,e,n,l,i),a(t,e,l+1,r,i)}}const y=(t,e)=>t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y,x=(t,e)=>{if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;const n=t.ll.x<e.ll.x?e.ll.x:t.ll.x,r=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:r,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}};let b=Number.EPSILON;void 0===b&&(b=Math.pow(2,-52));const v=b*b,m=(t,e)=>{if(-b<t&&t<b&&-b<e&&e<b)return 0;const n=t-e;return n*n<v*t*e?0:t<e?-1:1};class d{constructor(){this.reset()}reset(){this.xRounder=new E,this.yRounder=new E}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class E{constructor(){this.tree=new h,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(null!==n&&0===m(e.key,n.key))return this.tree.remove(t),n.key;const r=this.tree.next(e);return null!==r&&0===m(e.key,r.key)?(this.tree.remove(t),r.key):t}}const S=new d,_=11102230246251565e-32,w=134217729,k=(3+8*_)*_;function R(t,e,n,r,i){let o,s,l,h,u=e[0],f=r[0],c=0,p=0;f>u==f>-u?(o=u,u=e[++c]):(o=f,f=r[++p]);let g=0;if(c<t&&p<n)for(f>u==f>-u?(s=u+o,l=o-(s-u),u=e[++c]):(s=f+o,l=o-(s-f),f=r[++p]),o=s,0!==l&&(i[g++]=l);c<t&&p<n;)f>u==f>-u?(s=o+u,h=s-o,l=o-(s-h)+(u-h),u=e[++c]):(s=o+f,h=s-o,l=o-(s-h)+(f-h),f=r[++p]),o=s,0!==l&&(i[g++]=l);for(;c<t;)s=o+u,h=s-o,l=o-(s-h)+(u-h),u=e[++c],o=s,0!==l&&(i[g++]=l);for(;p<n;)s=o+f,h=s-o,l=o-(s-h)+(f-h),f=r[++p],o=s,0!==l&&(i[g++]=l);return 0===o&&0!==g||(i[g++]=o),g}function I(t,e){let n=e[0];for(let r=1;r<t;r++)n+=e[r];return n}function P(t){return new Float64Array(t)}const N=(3+16*_)*_,A=(2+12*_)*_,O=(9+64*_)*_*_,L=P(4),$=P(8),M=P(12),z=P(16),B=P(4);function G(t,e,n,r,i,o,s){let l,h,u,f,c,p,g,a,y,x,b,v,m,d,E,S,_,P;const N=t-i,G=n-i,T=e-o,C=r-o;d=N*C,p=w*N,g=p-(p-N),a=N-g,p=w*C,y=p-(p-C),x=C-y,E=a*x-(d-g*y-a*y-g*x),S=T*G,p=w*T,g=p-(p-T),a=T-g,p=w*G,y=p-(p-G),x=G-y,_=a*x-(S-g*y-a*y-g*x),b=E-_,c=E-b,L[0]=E-(b+c)+(c-_),v=d+b,c=v-d,m=d-(v-c)+(b-c),b=m-S,c=m-b,L[1]=m-(b+c)+(c-S),P=v+b,c=P-v,L[2]=v-(P-c)+(b-c),L[3]=P;let q=I(4,L),F=A*s;if(q>=F||-q>=F)return q;if(c=t-N,l=t-(N+c)+(c-i),c=n-G,u=n-(G+c)+(c-i),c=e-T,h=e-(T+c)+(c-o),c=r-C,f=r-(C+c)+(c-o),0===l&&0===h&&0===u&&0===f)return q;if(F=O*s+k*Math.abs(q),q+=N*f+C*l-(T*u+G*h),q>=F||-q>=F)return q;d=l*C,p=w*l,g=p-(p-l),a=l-g,p=w*C,y=p-(p-C),x=C-y,E=a*x-(d-g*y-a*y-g*x),S=h*G,p=w*h,g=p-(p-h),a=h-g,p=w*G,y=p-(p-G),x=G-y,_=a*x-(S-g*y-a*y-g*x),b=E-_,c=E-b,B[0]=E-(b+c)+(c-_),v=d+b,c=v-d,m=d-(v-c)+(b-c),b=m-S,c=m-b,B[1]=m-(b+c)+(c-S),P=v+b,c=P-v,B[2]=v-(P-c)+(b-c),B[3]=P;const U=R(4,L,4,B,$);d=N*f,p=w*N,g=p-(p-N),a=N-g,p=w*f,y=p-(p-f),x=f-y,E=a*x-(d-g*y-a*y-g*x),S=T*u,p=w*T,g=p-(p-T),a=T-g,p=w*u,y=p-(p-u),x=u-y,_=a*x-(S-g*y-a*y-g*x),b=E-_,c=E-b,B[0]=E-(b+c)+(c-_),v=d+b,c=v-d,m=d-(v-c)+(b-c),b=m-S,c=m-b,B[1]=m-(b+c)+(c-S),P=v+b,c=P-v,B[2]=v-(P-c)+(b-c),B[3]=P;const Y=R(U,$,4,B,M);d=l*f,p=w*l,g=p-(p-l),a=l-g,p=w*f,y=p-(p-f),x=f-y,E=a*x-(d-g*y-a*y-g*x),S=h*u,p=w*h,g=p-(p-h),a=h-g,p=w*u,y=p-(p-u),x=u-y,_=a*x-(S-g*y-a*y-g*x),b=E-_,c=E-b,B[0]=E-(b+c)+(c-_),v=d+b,c=v-d,m=d-(v-c)+(b-c),b=m-S,c=m-b,B[1]=m-(b+c)+(c-S),P=v+b,c=P-v,B[2]=v-(P-c)+(b-c),B[3]=P;const j=R(Y,M,4,B,z);return z[j-1]}function T(t,e,n,r,i,o){const s=(e-o)*(n-i),l=(t-i)*(r-o),h=s-l,u=Math.abs(s+l);return Math.abs(h)>=N*u?h:-G(t,e,n,r,i,o,u)}const C=(t,e)=>t.x*e.y-t.y*e.x,q=(t,e)=>t.x*e.x+t.y*e.y,F=(t,e,n)=>{const r=T(t.x,t.y,e.x,e.y,n.x,n.y);return r>0?-1:r<0?1:0},U=t=>Math.sqrt(q(t,t)),Y=(t,e,n)=>{const r={x:e.x-t.x,y:e.y-t.y},i={x:n.x-t.x,y:n.y-t.y};return C(i,r)/U(i)/U(r)},j=(t,e,n)=>{const r={x:e.x-t.x,y:e.y-t.y},i={x:n.x-t.x,y:n.y-t.y};return q(i,r)/U(i)/U(r)},V=(t,e,n)=>0===e.y?null:{x:t.x+e.x/e.y*(n-t.y),y:n},X=(t,e,n)=>0===e.x?null:{x:n,y:t.y+e.y/e.x*(n-t.x)},Q=(t,e,n,r)=>{if(0===e.x)return X(n,r,t.x);if(0===r.x)return X(t,e,n.x);if(0===e.y)return V(n,r,t.y);if(0===r.y)return V(t,e,n.y);const i=C(e,r);if(0==i)return null;const o={x:n.x-t.x,y:n.y-t.y},s=C(o,e)/i,l=C(o,r)/i;return{x:(t.x+l*e.x+(n.x+s*r.x))/2,y:(t.y+l*e.y+(n.y+s*r.y))/2}};class W{static compare(t,e){const n=W.comparePoints(t.point,e.point);return 0!==n?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:D.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){void 0===t.events?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,r=e.length;n<r;n++){const t=e[n];this.point.events.push(t),t.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(void 0===n.segment.consumedBy)for(let r=e+1;r<t;r++){const t=this.point.events[r];void 0===t.consumedBy&&n.otherSE.point.events===t.otherSE.point.events&&n.segment.consume(t.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,n=n=>{const r=n.otherSE;e.set(n,{sine:Y(this.point,t.point,r.point),cosine:j(this.point,t.point,r.point)})};return(t,r)=>{e.has(t)||n(t),e.has(r)||n(r);const{sine:i,cosine:o}=e.get(t),{sine:s,cosine:l}=e.get(r);return i>=0&&s>=0?o<l?1:o>l?-1:0:i<0&&s<0?o<l?-1:o>l?1:0:s<i?-1:s>i?1:0}}}let Z=0;class D{static compare(t,e){const n=t.leftSE.point.x,r=e.leftSE.point.x,i=t.rightSE.point.x,o=e.rightSE.point.x;if(o<n)return 1;if(i<r)return-1;const s=t.leftSE.point.y,l=e.leftSE.point.y,h=t.rightSE.point.y,u=e.rightSE.point.y;if(n<r){if(l<s&&l<h)return 1;if(l>s&&l>h)return-1;const n=t.comparePoint(e.leftSE.point);if(n<0)return 1;if(n>0)return-1;const r=e.comparePoint(t.rightSE.point);return 0!==r?r:-1}if(n>r){if(s<l&&s<u)return-1;if(s>l&&s>u)return 1;const n=e.comparePoint(t.leftSE.point);if(0!==n)return n;const r=t.comparePoint(e.rightSE.point);return r<0?1:r>0?-1:1}if(s<l)return-1;if(s>l)return 1;if(i<o){const n=e.comparePoint(t.rightSE.point);if(0!==n)return n}if(i>o){const n=t.comparePoint(e.rightSE.point);if(n<0)return 1;if(n>0)return-1}if(i!==o){const t=h-s,e=i-n,f=u-l,c=o-r;if(t>e&&f<c)return 1;if(t<e&&f>c)return-1}return i>o?1:i<o||h<u?-1:h>u?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,r){this.id=++Z,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=r}static fromRing(t,e,n){let r,i,o;const s=W.comparePoints(t,e);if(s<0)r=t,i=e,o=1;else{if(!(s>0))throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);r=e,i=t,o=-1}const l=new W(r,!0),h=new W(i,!1);return new D(l,h,[n],[o])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const i=(t.y-e.y)/r.y,o=e.x+i*r.x;if(t.x===o)return 0;const s=(t.x-e.x)/r.x,l=e.y+s*r.y;return t.y===l?0:t.y<l?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),r=x(e,n);if(null===r)return null;const i=this.leftSE.point,o=this.rightSE.point,s=t.leftSE.point,l=t.rightSE.point,h=y(e,s)&&0===this.comparePoint(s),u=y(n,i)&&0===t.comparePoint(i),f=y(e,l)&&0===this.comparePoint(l),c=y(n,o)&&0===t.comparePoint(o);if(u&&h)return c&&!f?o:!c&&f?l:null;if(u)return f&&i.x===l.x&&i.y===l.y?null:i;if(h)return c&&o.x===s.x&&o.y===s.y?null:s;if(c&&f)return null;if(c)return o;if(f)return l;const p=Q(i,this.vector(),s,t.vector());return null===p?null:y(r,p)?S.round(p.x,p.y):null}split(t){const e=[],n=void 0!==t.events,r=new W(t,!0),i=new W(t,!1),o=this.rightSE;this.replaceRightSE(i),e.push(i),e.push(r);const s=new D(r,o,this.rings.slice(),this.windings.slice());return W.comparePoints(s.leftSE.point,s.rightSE.point)>0&&s.swapEvents(),W.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),i.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=D.compare(e,n);if(0!==r){if(r>0){const t=e;e=n,n=t}if(e.prev===n){const t=e;e=n,n=t}for(let t=0,r=n.rings.length;t<r;t++){const r=n.rings[t],i=n.windings[t],o=e.rings.indexOf(r);-1===o?(e.rings.push(r),e.windings.push(i)):e.windings[o]+=i}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}beforeState(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let s=0,l=this.rings.length;s<l;s++){const t=this.rings[s],r=this.windings[s],i=e.indexOf(t);-1===i?(e.push(t),n.push(r)):n[i]+=r}const i=[],o=[];for(let s=0,l=e.length;s<l;s++){if(0===n[s])continue;const t=e[s],r=t.poly;if(-1===o.indexOf(r))if(t.isExterior)i.push(r);else{-1===o.indexOf(r)&&o.push(r);const e=i.indexOf(t.poly);-1!==e&&i.splice(e,1)}}for(let s=0,l=i.length;s<l;s++){const t=i[s].multiPoly;-1===r.indexOf(t)&&r.push(t)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(lt.type){case"union":{const n=0===t.length,r=0===e.length;this._isInResult=n!==r;break}case"intersection":{let n,r;t.length<e.length?(n=t.length,r=e.length):(n=e.length,r=t.length),this._isInResult=r===lt.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2==1;break}case"difference":{const n=t=>1===t.length&&t[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${lt.type}`)}return this._isInResult}}class H{constructor(t,e,n){if(!Array.isArray(t)||0===t.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],"number"!=typeof t[0][0]||"number"!=typeof t[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=S.round(t[0][0],t[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let i=r;for(let o=1,s=t.length;o<s;o++){if("number"!=typeof t[o][0]||"number"!=typeof t[o][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let e=S.round(t[o][0],t[o][1]);e.x===i.x&&e.y===i.y||(this.segments.push(D.fromRing(i,e,this)),e.x<this.bbox.ll.x&&(this.bbox.ll.x=e.x),e.y<this.bbox.ll.y&&(this.bbox.ll.y=e.y),e.x>this.bbox.ur.x&&(this.bbox.ur.x=e.x),e.y>this.bbox.ur.y&&(this.bbox.ur.y=e.y),i=e)}r.x===i.x&&r.y===i.y||this.segments.push(D.fromRing(i,r,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}class J{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new H(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,r=t.length;n<r;n++){const e=new H(t[n],this,!1);e.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=e.bbox.ll.x),e.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=e.bbox.ll.y),e.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=e.bbox.ur.x),e.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=e.bbox.ur.y),this.interiorRings.push(e)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getSweepEvents();for(let e=0,r=n.length;e<r;e++)t.push(n[e])}return t}}class K{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof t[0][0][0]&&(t=[t])}catch(n){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let r=0,i=t.length;r<i;r++){const e=new J(t[r],this);e.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=e.bbox.ll.x),e.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=e.bbox.ll.y),e.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=e.bbox.ur.x),e.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=e.bbox.ur.y),this.polys.push(e)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getSweepEvents();for(let e=0,r=n.length;e<r;e++)t.push(n[e])}return t}}class tt{static factory(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];if(!r.isInResult()||r.ringOut)continue;let i=null,o=r.leftSE,s=r.rightSE;const l=[o],h=o.point,u=[];for(;i=o,o=s,l.push(o),o.point!==h;)for(;;){const t=o.getAvailableLinkedEvents();if(0===t.length){const t=l[0].point,e=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${t.x}, ${t.y}]. Last matching segment found ends at [${e.x}, ${e.y}].`)}if(1===t.length){s=t[0].otherSE;break}let n=null;for(let e=0,i=u.length;e<i;e++)if(u[e].point===o.point){n=e;break}if(null!==n){const t=u.splice(n)[0],r=l.splice(t.index);r.unshift(r[0].otherSE),e.push(new tt(r.reverse()));continue}u.push({index:l.length,point:o.point});const r=o.getLeftmostComparator(i);s=t.sort(r)[0].otherSE;break}e.push(new tt(l))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let h=1,u=this.events.length-1;h<u;h++){const n=this.events[h].point,r=this.events[h+1].point;0!==F(n,t,r)&&(e.push(n),t=n)}if(1===e.length)return null;const n=e[0],r=e[1];0===F(n,t,r)&&e.shift(),e.push(e[0]);const i=this.isExteriorRing()?1:-1,o=this.isExteriorRing()?0:e.length-1,s=this.isExteriorRing()?e.length:-1,l=[];for(let h=o;h!=s;h+=i)l.push([e[h].x,e[h].y]);return l}isExteriorRing(){if(void 0===this._isExteriorRing){const t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let r=1,i=this.events.length;r<i;r++){const e=this.events[r];W.compare(t,e)>0&&(t=e)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class et{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}class nt{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}_composePolys(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];if(!r.poly)if(r.isExteriorRing())e.push(new et(r));else{const t=r.enclosingRing();t.poly||e.push(new et(t)),t.poly.addInterior(r)}}return e}}class rt{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:D.compare;this.queue=t,this.tree=new h(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const r=t.isLeft?this.tree.add(e):this.tree.find(e);if(!r)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let i,o,s=r,l=r;for(;void 0===i;)s=this.tree.prev(s),null===s?i=null:void 0===s.key.consumedBy&&(i=s.key);for(;void 0===o;)l=this.tree.next(l),null===l?o=null:void 0===l.key.consumedBy&&(o=l.key);if(t.isLeft){let r=null;if(i){const t=i.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(r=t),!i.isAnEndpoint(t))){const e=this._splitSafely(i,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}}let s=null;if(o){const t=o.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(s=t),!o.isAnEndpoint(t))){const e=this._splitSafely(o,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}}if(null!==r||null!==s){let t=null;t=null===r?s:null===s||W.comparePoints(r,s)<=0?r:s,this.queue.remove(e.rightSE),n.push(e.rightSE);const i=e.split(t);for(let e=0,r=i.length;e<r;e++)n.push(i[e])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=i)}else{if(i&&o){const t=i.getIntersection(o);if(null!==t){if(!i.isAnEndpoint(t)){const e=this._splitSafely(i,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}if(!o.isAnEndpoint(t)){const e=this._splitSafely(o,t);for(let t=0,r=e.length;t<r;t++)n.push(e[t])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const r=t.split(e);return r.push(n),void 0===t.consumedBy&&this.tree.add(t),r}}const it="undefined"!=typeof process&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,ot="undefined"!=typeof process&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class st{run(t,e,n){lt.type=t,S.reset();const r=[new K(e,!0)];for(let h=0,f=n.length;h<f;h++)r.push(new K(n[h],!1));if(lt.numMultiPolys=r.length,"difference"===lt.type){const t=r[0];let e=1;for(;e<r.length;)null!==x(r[e].bbox,t.bbox)?e++:r.splice(e,1)}if("intersection"===lt.type)for(let h=0,f=r.length;h<f;h++){const t=r[h];for(let e=h+1,n=r.length;e<n;e++)if(null===x(t.bbox,r[e].bbox))return[]}const i=new h(W.compare);for(let h=0,f=r.length;h<f;h++){const t=r[h].getSweepEvents();for(let e=0,n=t.length;e<n;e++)if(i.insert(t[e]),i.size>it)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const o=new rt(i);let s=i.size,l=i.pop();for(;l;){const t=l.key;if(i.size===s){const e=t.segment;throw new Error(`Unable to pop() ${t.isLeft?"left":"right"} SweepEvent [${t.point.x}, ${t.point.y}] from segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] from queue.`)}if(i.size>it)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(o.segments.length>ot)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const e=o.process(t);for(let n=0,r=e.length;n<r;n++){const t=e[n];void 0===t.consumedBy&&i.insert(t)}s=i.size,l=i.pop()}S.reset();const u=tt.factory(o.segments);return new nt(u).getGeom()}}const lt=new st,ht=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("union",t,n)},ut=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("intersection",t,n)},ft=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("xor",t,n)},ct=function(t){for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];return lt.run("difference",t,n)};return{union:ht,intersection:ut,xor:ft,difference:ct}}()}}]);